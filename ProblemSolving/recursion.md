### 도대체 재귀는 어떻게 해야 쉽게 써먹을 수 있을까?
    
    재귀적으로 생각하지 않기.
    
    재귀는 큰 문제를 여러 문제로 쪼갠 후, 그 쪼개진 답을 합쳐서 구하는 방식이라고 생각하기
    (Divide & conquer)
    
    5단계로 나누어서 알고리즘 설계를 진행한다.
    
    1. 재귀가 필요한지 판단
        
        재귀로 풀 수 있는 것은 반복문으로도 풀 수 있고,
        반복문으로 푸는 것이 성능도 더 좋다.
        왜냐하면 재귀처럼 함수를 계속 호출함으로써 드는 오버헤드
        (다시 돌아가야할 위치 저장, 프레임 생성 등등)이 없기 때문이다.
        
        재귀로 풀게되면 단지 더 깔끔하게 풀 수 있을 뿐이다.
        
        반복문으로도 깔끔하게 풀 수 있다면 반복문을 쓰자.
        
    2. 종료 조건 구하기
        
        종료 조건은 재귀가 끝나는 조건이다.
        
        이 재귀 함수의 가장 간단한 케이스를 생각해서 종료 조건으로 정한다.
        
        어떤 정수가 인풋이라면, 이 인풋이 0이 될때,
        인풋이 2개라면 (0, 0) (1, 0) (0, 1) (1, 1)등이 종료 조건이 될 수 있다.
        
        이 종료 조건을 재귀 함수에 가장 처음에 if문으로 등록시켜준다.
        
    3. 종료 조건에 어떻게 하면 도달할 수 있을지 생각한다.
        
        ex) 종료 조건이 정수0이라면 함수를 실행할 때마다 input값을 -1해준다.
        
    4. 종료 조건 바로 윗 단계와 3단계 위를 모두 만족하는 형태의 알고리즘 작성
        
        예를 들어 1부터 n까지 모두 더하는 문제가 있다고 하자.
        
        f(1)이 종료 조건이 된다.
        
        종료 조건 바로 윗 단계는 f(2), 3단계 위는 f(4)이다.
        
        실제로 손으로 계산을 한다.
        
        f(2) = 3 , f(4) = 10이다.
        
        이 둘을 만족하는 알고리즘을 어떻게 작성할 것인가?
        
        f(2)같은 경우 종료 조건을 이용한다.
        
        f(1)일 경우 1이므로 f(2) = 2 + f(1)이라고 생각해볼 수 있다.
        
        f(4)는 f(3)까지 제대로 구해졌다는 가정 하에 f(4) = 4 + f(3)이라고 할 수 있다.
        
        이 때 f(3)까지는 제대로 구해진다고 믿는게 중요하다.
        
        따라서 일반화 시켜보면 f(n) = n + f(n - 1)이다.
        
        최종적인 재귀 함수는 이렇게 된다.
        
        int f(int n){
        	if(n == 1) return 1;
        	return n + f(n-1)
        }
        
    
    5. 위를 뼈대라고 한다면 이 뼈대를 바탕으로 추가적인 조건들을 채워나간다.
        
        
    
    참고 자료
    
    [https://velog.io/@eddy_song/you-can-solve-recursion](https://velog.io/@eddy_song/you-can-solve-recursion)

### 