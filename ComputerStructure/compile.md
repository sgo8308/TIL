### 컴파일이라는 것은 무엇이며 내부적으로 어떤 과정을 거칠까? ★
    
    컴파일은 내가 만든 프로그램 코드를 컴퓨터가 이해할 수 있도록 엮어주는 작업이다.
    
    Source code를 원하는 언어로 번역하는 과정이다.
    
    C언어 빌드 과정
    
    - 전처리 과정
        
        Pre-processing
        
        컴파일을 진행하기 전에 전처리를 진행한다. (*.c) 파일을 (*.i) 파일로 변환한다.
        
        ex) 주석 제거, 헤더 파일 삽입(#include를 만나면 해당하는 헤더 파일을 찾아 모두 복사에서 소스 코드에 삽입)
        
    - 컴파일 과정
        
        컴파일러를 통해 전처리된 소스 코드 파일(*.i)을 어셈블리어 파일(*.s)로 변환한다.
        
        1. Tokenizing
            
            언어에 정의된 각각의 토큰을 체크하는 과정
            
            if(a >= 1) continue;
            
            라는 코드가 있을 때 토큰은 IF, LP, STR, GTR, NUM, RP, CONTINUE, SEMICOL 등이 있다.
            
        2. Parsing
            
            각 토큰들이 문법에 맞게 제대로 배치되었는지 확인하는 과정
            
            ex) if 다음에는 반드시 왼쪽 괄호가 오므로 LP(left paranthesis)가 아닌 경우 에러
            
        3. Optimization
            
            코드를 최적화하는 과정, 이 때 CPU에 비종속적인 최적화와 종속적인 최적화를 나눠서 처리한다. 같은 기능을 수행하는 명령어여도 CPU 아키텍처별로 더욱 효율적인 명령어가 있기 때문에.
            
            ex) For문을 100만번 도는데 안에 a=1밖에 없다면 for문을 삭제한다.
                  꼬리재귀 함수는 일반적인 for문으로 만들어 준다.
            
        4. Generation Code
            
            어셈블리 코드를 생성한다. 어셈블리어는 CPU 명령어와 1대1로 매칭된다.
            
    - 어셈블리 과정
        
        어셈블러를 이용해 어셈블리어(*.s)를 오브젝트 파일(*.o)로 변환하는 과정이다.
        
        오브젝트 파일은 기계어이다.
        
    - 링킹 과정
        
        링커를 사용해 오브젝트 파일들을 묶어 실행 파일로 만드는 과정이다.
        이 과정에서 오브젝트 파일들과 프로그램에서 사용하는 라이브러리 파일들을 링크하여 하나의 실행 파일을 만든다.
        
        각각의 오브젝트 파일의 각 섹션이 하나로 합쳐진다. 텍스트 영역은 텍스트 영역끼리 데이터 영역은 데이터 영역 끼리. 이 때 어떤 메소드가 어느 주소에 있는지 어떤 변수가 어느 주소에 있는지 등이 기록된다.
        
        실행파일은 미해결된 참조를 갖고 있지 않는 오브젝트 파일이라 볼 수 있다.
        
    
    출처 
    
    [https://www.slideshare.net/jongyoungpark2/java-class-file-format](https://www.slideshare.net/jongyoungpark2/java-class-file-format)
    위키피디아 : 컴파일러
    [https://bradbury.tistory.com/226](https://bradbury.tistory.com/226)
    
    David A. Patterson 외 1명, 컴퓨터 구조 및 설계, 초판 1쇄, 한티미디어, 145-147, 2021
    
### 왜 빌드시 바로 실행 파일로 변환하지 않고 오브젝트 파일을 한 번 거칠까?
    
    이미 만들어진 실행 파일은 서로 링크하는게 불가능하기 때문에 이게 가능하려면 빌드시 필요한 모든 것(내 소스 코드, 의존하는 라이브러리)들이 소스 파일 형태로 존재해야 한다.
    
    일단은 처음엔 이렇게 해서 빌드한다고 하더라도 만약 내가 작성한 소스코드를 조금이라도 고쳐야 한다면 고친 후 다시 이 모든 것들을 재컴파일해야 한다. 이 과정이 시간이 너무 오래 걸린다.  
    
    따라서 따로따로 컴파일해서 오브젝트 파일로 변환해두고 링커를 통해 실행 파일로 만드는 것이다.
    
    어떤 모듈이 변했다면 그 모듈만 다시 컴파일하면 되서 시간이 절약된다.
    
    ---
    
    David A. Patterson 외 1명, 컴퓨터 구조 및 설계, 초판 1쇄, 한티미디어, 145p, 2021
    
### 정적 링킹과 동적 링킹의 차이는?
    
    정적 링킹은 링커에 의해서 이루어진다.
    
    정적 링킹의 경우 어떤 프로그램이 의존하는 라이브러리의 모든 코드를 하나의 실행 파일로 합쳐야 하기 때문에 실행 파일에 크기가 크다. 만약 하나의 라이브러리를 여러 프로그램이 사용한다면 이 프로그램이 모두 같은 코드를 복사해서 들고 메모리에 존재하기 때문에 중복이 있어 메모리 효율적이지도 않다. 
    
    또한 라이브러리가 업데이트 되었을 때 다시 재컴파일하여 실행 파일로 만들지 않는 한 여전히 이전 라이브러리를 사용해야 한다.
    
    하지만 상대적으로 실행이 빠르며 항상 라이브러리를 복사해서 들고 있기 때문에 호환성 이슈가 발생하지 않는다.
    
     
    
    동적 링킹은 운영체제에 의해서 이루어진다.
    
    동적 링킹은 프로그램이 자신이 의존하는 라이브러리 안에 메소드의 주소를 갖고 있다가 실제로 메소드가 호출할 때 운영체제에 의해서 그 주소로 이동해 메소드를 실행하는 방식이다.
    
    따라서 동적 링킹처럼 실행 파일 안에 모든 라이브러리의 코드를 포함할 필요가 없어 크기가 작다. 또한 여러 프로그램들이 하나의 라이브러리를 공유할 수 있기 때문에 메모리 효율적이다.
    
    또 라이브러리가 업데이트 되는 경우 이 라이브러리만 새로 컴파일하면 이 라이브러리를 사용하는 다른 프로그램들은 재컴파일하지 않아도 업데이트된 라이브러리를 사용할 수 있다. 주소를 따라가면 그 자리에 업데이트된 라이브러리가 있기 때문이다.
    
    어떤 메소드를 처음 호출할 때 오버헤드가 매우 크다. 라이브러리의 메소드가 있는 곳으로 찾아가는 과정이 복잡하기 때문이다. 그러나 그 다음부터는 바로 그 위치로 점프하기 때문에 추가적인 오버헤드가 사라진다.
    
    라이브러리에 변경이 생겼을 때 갑자기 현재 실행하는 프로그램과 호환되지 않아 문제가 발생할 수 있다.
    
    ---
    
    [https://cs-fundamentals.com/tech-interview/c/difference-between-static-and-dynamic-linking.php]
    
    David A. Patterson 외 1명, 컴퓨터 구조 및 설계, 초판 1쇄, 한티미디어, 149, 2021