### 쓰레드는 어떠한 배경에서 등장했을까?
    
    과거에는 두 가지 이상의 일을 동시에 처리하기 위해서, 혹은 둘 이상의 실행 흐름을 처리하기 위해서 하나의 프로그램에서 둘 이상의 프로세스(프로세스 링크)를 생성하는 일이 많았다고 한다.
    
    예를 들면 여러 서버 프로세스를 만들어 클라이언트로부터의 요청을 동시에 처리하곤 했다.
    
    서로 별개의 프로그램을 위해서는 어쩔 수 없는 일이지만 하나의 프로그램이 둘 이상의 프로세스 생성을 요구하는 것은 부담스러운 일이다.
    
    왜냐하면 프로세스가 많아질수록 컨텍스트 스위칭이 많아지고 프로세스의 생성 또한 오랜 시간이 걸리기 때문이다.
    
    위와 같은 문제를 해결하기 위해 쓰레드가 등장하였다.
    
    ---
    
    윤성우, 뇌를 자극하는 윈도우즈 시스템 프로그래밍, 10쇄, 한빛미디어, 352p, 2021 
    
    Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 177p,2020
    
### 쓰레드란 무엇일까?
    
    쓰레드란 프로세스 내에서 실행되는 흐름 중 하나를 말한다.
    
    메모리 구조 관점에서 볼 때 프로세스는 서로 완전히 다르다.
    따라서 컨텍스트 스위칭시 많은 컨텍스트 정보를 저장하고 복원해야 한다.
    
    반면에 쓰레드는 code 영역 data 영역 heap 영역을 공유한다.
    (JVM 관점에서 보면 method area, heap 영역 등을 공유한다고 할 수 있다.)
    
    따라서 쓰레드간 컨텍스트 스위칭 시 보다 적은 정보(메모리 관련 정보를 저장할 필요 없음)를 저장하고 복원하기 때문에 프로세스 간 컨텍스트 스위칭보다 적은 시간이 소요된다.
    
    일반적으로 프로그램은 하나의 스레드를 갖고 있고, 둘 이상의 스레드를 가진 프로세스를 멀티쓰레드 프로세스라고 한다.
    
    
### 프로세스와 쓰레드의 차이는?
    
    프로세스는 서로 독립적이고 하나의 프로그램 안에 있는 쓰레드들 사이에는 서로 공유하는 요소들이 있다. 따라서 컨텍스트 스위칭에 걸리는 시간이 짧다.
    
    프로세스가 데이터를 공유하려면 IPC기법을 사용해야하는 반면에 쓰레드는 heap 영역이나 data 영역을 통해서 좀 더 쉽게 데이터를 공유할 수 있다.
    
    프로세스는 생성과 종료에 시간이 많이 드는 반면 쓰레드는 생성과 종료에 비교적 시간이 덜 든다.
    
### 컨텍스트 스위칭이란?
    
    컨텍스트 스위칭이란 프로세스 혹은 쓰레드가 다른 프로세스 혹은 다른 쓰레드로 스케쥴링 될 때
    현재까지의 상태(혹은 문맥)를 저장하고 다시 돌아왔을 때 이 상태를 복원하는 작업이다.
    
    이 상태는 PCB라는 자료구조에 저장된다. 
    
    쓰레드는 메모리 영역을 공유하기 때문에 메모리 영역과 관련된 페이지 테이블 레지스터, MMU에 존재하는 기준 레지스터 값과 한계 레지스터 값 등을 저장하고 복원할 필요가 없다.
    
    이러한 이유로 프로세스 컨텍스트 스위칭보다 컨텍스트 스위칭에 걸리는 시간이 짧다.
    
    프로세스는 컨텍스트 스위칭 시 TLB와 cache에 저장된 요소가 flush 되기 때문에 스위칭 후 얼마간 프로세스에 성능 저하가 발생할 수 있다.
    
    그러나 위와 같은 문제는 프로세스 식별자를 비롯한 다양한 해결책이 사용되기 때문에 스레드 컨텍스트 스위칭보다 크게 불리한 점이라고 생각되지는 않는다.
    
### 멀티 쓰레드 방식은 언제 사용할까?
    1. 어떤 일이 동시에 처리되야 할 경우
        
        예를 들어 싱글 쓰레드 방식의 서버 프로그램이 있다고 하자.
        
        사용자가 요청을 한 경우 하나의 쓰레드가 맡아서 요청을 처리해야 한다.
        
        요청을 처리하는 중에 다른 사용자가 또 요청을 하는 경우 이 요청이 완료되기까지 기다려야 할 것이다.
        
        멀티쓰레드라면 각 요청을 각 쓰레드가 하나씩 맡아서 동시에 요청을 처리할 수 있다. 
        
    2. 어떤 일을 빠르게 처리하고 싶은 경우
        
        예를 들어 1부터 100까지 더해야하고 한번에 더하기 연산을 하는데 1초가 걸린다고 가정해보자.
        
        싱글 쓰레드의 경우 1부터 100까지 더하는데 100초가 걸린다.
        
        쓰레드가 4개이고 각각 1/4씩 나누어서 처리한 후 모두 더해주면 약 25초가 걸린다.
        
        하지만 모든 상황에서 멀티쓰레드로 작업을 처리하는게 싱글쓰레드보다 빠르지 않으므로 상황을 잘 판단해서 사용해야 한다.
        
### 쓰레드가 많으면 무조건 작업을 빨리 처리할까?
    
    아니다. 
    
    쓰레드가 많아도 코어가 쓰레드의 갯수보다 적다면 컨텍스트 스위칭을 하며 작업을 처리해야 하고 컨텍스트 스위칭에는 시간이 소요 되기 때문에 오히려 느릴 수도 있다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 723p, 2016
    
### 멀티쓰레드 프로세스에서 하나의 쓰레드에 예외나 에러가 발생하면 어떻게 될까?
    
    예외나 에러가 발생한 쓰레드만 종료되며 나머지 쓰레드는 정상 실행된다.
    
    heap은 공유하는데 왜 oome가 떠도 정상실행되지?
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 730p, 2016
    
    직접 실험
    
### OS의 스케쥴링과 쓰레드의 관계는 어떻게 될까?
    
    대부분 최신 운영체제에서 스케줄 되는 대상은 프로세스가 아니라 커널 수준 쓰레드이다.
    
    프로세스 간 컨텍스트 스위칭은 어떤 프로세스에 있는 쓰레드에서 다른 프로세스에 있는 쓰레드로 스케쥴링 될 때를 의미한다.
    
    자바의 쓰레드 또한 OS에 의해 관리되고 스케쥴링된다.
    
    ---
    
    윤성우, 뇌를 자극하는 윈도우즈 시스템 프로그래밍, 10쇄, 한빛미디어, 360p, 2021 
    
    Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 239p,2020
    
### CPU 코어 개수와 스레드 개수의 상관 관계는 어떻게 될까?
    
    CPU 코어의 개수에 따라서 병렬적으로 실행할 수 있는 쓰레드의 개수가 정해진다.
    
    예를들어 CPU 코어가 4개이고 스레드 또한 4개라면 이 쓰레드들은 모두 병렬적으로 실행이 가능하다.
    
    그러나 CPU 코어가 1개이고 스레드가 4개라면 이 스레드들은 CPU 코어 하나가 빠르게 왔다갔다 하면서 처리하기 때문에 병렬적으로 실행되는 것처럼 보여도 실은 병렬적이지 않다.
    
    한 편 하이퍼스레드라는 기술은 운영체제에게 코어 하나가 여러개로 인식되게끔 할 수 있다.
    
    이 기술은 코어 하나가 어떤 쓰레드에 대한 작업 중 메모리 스톨 때문에 비어버린 시간을 다른 쓰레드에 할당하는 기술이다.
    
    따라서 8코어 CPU가 하이퍼 쓰레드 기술에 의해 16코어처럼 운영체제에 인식되더라도 병렬적으로 실행할 수 있는 쓰레드는 역시 8개라고 할 수 있다.
    
    ---
    
    Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 244p,2020
    
### 쓰레드는 자바에서 어떻게 사용할까?
    1. Thread 클래스를 상속, Runnable 인터페이스를 구현
        
        class MyThread extends Thread{
        	public void run() { /* 작업내용 */} //Thrad클래스의 run()을 오버라이딩
        }
        
        class MyRunnable implements Runnable{
        	public void run(){/*작업내용*/} //Runnable 인터페이스의 추상메서드 run()을 구현
        }
        
        class Th1{
        	public void main(String args[]){
        		MyThread t1 = new MyThread();
        		MyRunnable r = new MyRunnable();
        		Thread t2 = new Thread(r); // 생성자로 Runnable을 전달하면 start()시 run()메소드를 호출해줌
        	
        		// 2가지 방법 다 Thread 클래스의 start()메소드를 사용해야 쓰레드가 시작이 된다.
        		t1.start();
        		t2.start();
        	}
        }
        
    2. Callable 인터페이스를 구현
        
        class MyRunnable implements Callable<Integer>{
        	public void call(){/*작업내용*/} //Runnable 인터페이스의 추상메서드 run()을 구현
        }
        
### 쓰레드를 만든다는 것은 어떤 의미일까?
    
    프로세스의 스택 영역에 스레드의 스택 공간을 만든다.
    
    스레드의 정보를 저장할 TCB를 만들어 커널 영역에 보관한다.
    
    OS의 스케쥴링 큐에 TCB에 대한 포인터를 넣는다.
    
    (Operation System Concepts 123p를 보면 스케쥴링 큐에 PCB의 포인터를 넣는다고 나와 있다. 한 편 실제로 스케쥴링되는 단위는 쓰레드이고, TCB는 PCB에 대한 포인터를 갖고 있기 때문에 스케쥴링 큐에 TCB에 대한 포인터가 넣어진다고 러프하게 이해할 수 있을 것 같다.)
    
    등등의 작업을 하는 것이 스레드를 만든다는 것의 의미다.
    
    - TCB(Thread Control Block)란?
        
        쓰레드의 문맥을 저장하는 자료 구조.
        
        다음과 같은 정보를 저장한다.
        
        1. 실행 상태 : 프로세서 레지스터, 프로그램 카운터, 스택 포인터
        2. 스케줄링 큐용 다양한 포인터
        3. 해당 스레드를 포함하는 프로세스의 PCB를 포함하는 포인터 
    

## Advanced

### JVM의 쓰레드 스케쥴링 방식과 OS의 스케쥴링 방식은 어떻게 상호작용할까?
    
    JVM은 쓰레드 스케쥴링을 OS에 맡기는 듯하다.
    
    ---
    
    [https://stackoverflow.com/questions/2816011/what-is-the-jvm-thread-scheduling-algorithm](https://stackoverflow.com/questions/2816011/what-is-the-jvm-thread-scheduling-algorithm)
    
    [https://stackoverflow.com/questions/41759261/how-jvm-thread-scheduler-control-threads-for-multiprocessors](https://stackoverflow.com/questions/41759261/how-jvm-thread-scheduler-control-threads-for-multiprocessors)
    
### 각 OS는 어떤 스케쥴링 방식을 사용할까?
    
    리눅스는 Completely Fair Scheduling(CFS)라는 알고리즘을 사용하는 듯하다.
    
    [https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/#:~:text=Linux uses a Completely Fair,the CPU among running threads](https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/#:~:text=Linux%20uses%20a%20Completely%20Fair,the%20CPU%20among%20running%20threads).
    
### 멀티 코어에서는 어떻게 스케쥴링이 될까?
    
    보통 2가지 방식이 있다.
    
    모든 스레드가 공통 준비 큐에 존재해서 각 코어가 하나씩 스레드를 가져가면서 처리하는 모델이다.
    
    두 개의 다른 프로세서가 동일한 스레드를 스케줄 하지 않도록 관리가 필요하다.
    
    다른 하나는 각 코어가 자신만의 준비 큐를 갖고 있는 모델이다.
    
    첫번째 모델과 같은 문제가 없고 캐시 메모리를 효율적으로 사용할 수 있는 반면 각각의 큐마다 부하의 양이 다를 수 있다. (한 쓰레드가 다른 프로세서로 넘어가기 쉬운 첫번째 방법은 캐쉬 메모리를 매번 리셋해야 할 확률이 크다.)
    
    한 편 부하의 문제도  균형 알고리즘을 사용하여 모든 프로세서 간에 부하를 균등하게 만들 수 있기 때문에 대부분의 최신 운영체제에서는 일반적으로 두번째 방법을 택한다.
    
    Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 243p,2020
    
### 사용자 수준 쓰레드와 커널 수준 쓰레드의 차이는?
    
    사용자 수준 쓰레드는 커널 쓰레드 위에서 동작한다.
    
    사용자 수준 쓰레드는 스레드 라이브러리에 의해서 스레드 관련 정보가 관리되고 스케쥴링 된다.
    
    커널 쓰레드는 OS에 의해서 관련 정보가 관리되고 스케쥴링 된다.
    
    사용자 수준 쓰레드와 커널 수준 쓰레드간에는 다대일, 일대일, 다대다 등의 관계가 있다.
    
    다대일 관계에서는 여러 사용자 수준 쓰레드가 하나의 커널 수준 쓰레드에 대응된다.
    
    따라서 어떤 사용자 수준 쓰레드가 스케쥴링 되었다고 해서 실제로 실행된다고 할 수는 없다.
    
    대응되는 커널 수준 쓰레드가 OS에 의해서 실제로 스케쥴링이 되어야 하기 때문이다.
    
    일대일 관계에서 사용자 수준 쓰레드는 커널 수준 쓰레드와 일대일로 대응된다.
    이 때 사용자 수준 쓰레드를 한 개 만들면 이와 대응되는 커널 수준 쓰레드가 만들어지며, 
    사용자 수준 쓰레드가 작업을 마치고 종료되면, 커널 수준 쓰레도도 같이 종료된다.
    
    일대일 관계에서 사용자 수준 쓰레드의 스케쥴링은 커널 수준 쓰레드의 스케쥴링에 의존된다.
    
    다대다 관계는 일대일 관계를 사용했을 때 발생하는 커널 쓰레드가 너무 많아지는 문제를 해결한다.
    
    그러나 요즈음 대부분의 운영체제는 일대일 관계 모델을 사용한다.
    
    왜냐하면 다대일 관계는 다중 코어를 제대로 활용할 수 없고 다대다 관계는 구현하기가 어렵고 대부분의 시스템에서 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었기 때문이다. 
    
    ---
    
    Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 184p, 234p,2020
    
### 쓰레드의 우선순위는 믿을만한가?
    
    JVM마다 쓰레드의 우선순위와 관련된 구현이 다르고, OS마다 다른 방식으로 스케쥴링하기 때문에 어떤 OS에서 실행하느냐에 따라서도 다른 결과를 얻을 수 있다.
    
    따라서 어떤 스레드의 높은 우선순위를 준다고 해서 더 많은 실행시간과 실행기회를 갖게 될 것이라고 확신해서는 안된다
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 740p, 2016
    
### 그럼 쓰레드 우선순위는 언제 쓰면 좋을까?
### 쓰레드 그룹이란?
    
    쓰레드 그룹이란 서로 관련된 쓰레드의 그룹이다.
    
    마치 폴더를 생성해서 관련 있는 파일을 관리하는 것처럼 쓰레드를 그룹으로 묶어서 관리할 수 있다.
    
    주로 쓰레드그룹의 모든 쓰레드를 한번에 interrupt() 하는 용도로 사용한다.
    
    모든 쓰레드는 반드시  쓰레드 그룹에 포함되야 하며 쓰레드 그룹은 다른 쓰레드 그룹을 포함할 수 있다.
    
    쓰레드 그룹을 지정하지 않고 생성된 쓰레드는 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속하게 된다.
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 742p, 2016
    
### 쓰레드 풀이란?
    
    미리 다수의 쓰레드를 만들어 놓은 곳.
    
    쓰레드를 반복해서 생성하지 않아도 되며, 너무 많은 쓰레드가 생성되어 성능이 저하되는 것을 막아준다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 789p, 2016
    
### 데몬 쓰레드란?
    
    다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드
    
    다른 쓰레드가 없다면 존재 이유가 없기 때문에 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다.
    
    예를 들어 가비지 컬렉터, 워드프로세서의 자동저장, 화면자동갱신 등이 있다.
    
### Thread의 메소드 start()와 Runnable의 메소드 run()의 차이는?
    
    Thread 메소드의 start()는 내부에서 native 메소드를 실행시킨다. 
    
    그리고 이 native 메소드는 쓰레드를 생성하고 새로운 쓰레드에 필요한 호출스택을 생성한다.
    
    run()은 일반적인 메소드로 위에 생성된 호출스택에 첫 번째로 올라간다.
    
    쓰레드가 종료되면 이렇게 만들어진 호출스택도 소멸된다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 729p, 2016
    
### 메인 쓰레드가 종료되면 프로그램이 종료될까?
    
    아니다. 데몬 쓰레드를 제외한 모든 쓰레드가 작업을 마칠 때까지 프로그램은 종료되지 않는다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 729p, 2016
    
### synchronized block에 소괄호 안에 들어가는 객체는 무엇을 의미할까?
    
    lock을 거는 대상이다. 보통은 this라는 키워드로 현재 객체를 넣는다.
    
    이 소괄호 안에 현재 메소드가 실행되는 객체를 집어넣는 것이 아니라 다른 객체를 집어 넣으면 쓰레드가 획득하는 락은 다른 객체의 락이 된다.
    
    wait 또한 다른 객체의 wating pool에 들어가게 되며 notify 또한 다른 객체에 wating pool에 notify한다.
    
    일반적인 synchronized 메소드는 현재 객체의 락을 얻게 된다.
    
    ---
    
    [https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html)
    
    직접 실험
    
### Runnable과 Callable의 차이는?
    
    Runnable은 반환값이 없는 반면 Callable은 반환 값이 있다. 또 Callable은 checked 예외를 던질 수 있다.
    
### fork & join framework이란?
    
    쓰레드 풀을 사용하여 어떤 작업을 나눠서 처리하는데 도움을 주는 프레임워크
    
    한 쓰레드가 어떤 작업을 충분히 작아질 때 까지 나누어서 자신의 작업큐에 넣으면
    
    다른 노는 쓰레드들이 작업큐에서 작업을 훔쳐와서 작업을 한다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 788-792, 2016
    
### volatile 키워드란?
    
    volatile 키워드를 사용한 변수는 cpu가 변수를 읽어올 때 캐시가 아닌 메모리에서 읽어온다.
    
    또 변수를 읽고 쓰는 과정을 원자화 시켜서 다른 쓰레드가 중간에 끼어들 수 없게 한다.
    
    ---
    
    남궁 성, 자바의 정석 3rd Edition, 1판 2쇄, 도우출판, 786-787, 2016
    
### 가시성과 원자성이란?
    - 가시성
        
        가시성은 CPU가 캐시에 눈이 멀지 않고 메모리에 있는 데이터를 똑바로 볼 수 있을 때 가시성이 보장된다고 한다.
        
    - 원자성
        
        원자성이란 어떠한 연산이 중간에 개입없이 단 한번에 일어나는 것을 말한다.
        이 연산은 완벽하게 수행되거나, 수행되지 않을 것이다.
        
        i++연산의 경우 일반적으로 CPU에서 3번이 연산이 일어나므로 원자적이지 않다.
        
        long과 double을 제외하고 참조 변수나 기본형 변수를 읽거나 쓰는 작업은 원자적이다.
        
        volatile을 앞에 붙히면 long과 double의 읽기와 쓰기에서의 원자성을 보장할 수 있다.
        
    
    ---
    
    [https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html](https://docs.oracle.com/javase/tutorial/essential/concurrency/atomic.html)

### Atomic 개체들과 cas 알고리즘에 대해 설명해주세요.

    Atomic 객체들은 이 객체에 대한 연산을 원자적으로 할 수 있다.
    
    예를 들어 i++와 같은 연산을 원자적으로 할 수 있다.
    
    이 객체들에 대한 연산의 경우 CAS 알고리즘을 통해 lock을 걸지 않고 동시성 문제를 해결할 수 있다.
    
    lock을 걸지 않기 때문에 블락이 되고 다시 풀리는 등의 쓰레드 상태를 바꾸어주는 커널 모드로의 전환이 없어 오버헤드가 적다.

    - CAS 알고리즘의 동작 원리는?

      CAS 알고리즘은 하드웨어로부터 동기화 지원을 받는 것이다.

      A라는 변수는 1000이라는 주소에 있고 1이라는 값이 담겨져 있다고 하자.

      이 때 CAS 알고리즘으로 1이라는 값을 2로 만든다면 다음과 같은 과정이 일어난다.

      CPU가 1000이라는 주소에 값을 읽고 2를 1000이라는 주소에 저장할 때 만약 1000이라는 주소에 1이 그대로 있다면 2를 저장하고 없다면 실패하게 된다.

      이러한 과정이 원자적으로 일어난다.

      MIPS 같은 경우는 2개의 인스터럭션(load linked, store conditional)으로 일어나지만 마지막 인스터럭션이 위와 같이 확인 과정을 거치기 때문에 2개의 인스트럭션이 원자적으로 일어난다.

      ARM은 하나의 인스트럭션으로 load와 store를 원자적으로 진행하기 때문에 다른 프로세스나 쓰레드가 끼어들 틈이 없다.
        
      ---

      [https://gusdnd852.tistory.com/255](https://gusdnd852.tistory.com/255)

      Abraham Silberschatz 외 2명, 운영체제, 박민규, 1쇄, 퍼스트 북, 291~,2020

### CAS 알고리즘이 lock에 비해 이득이 있는 경우?
    
      어떤 변수에 대한 값을 업데이트하고 바로 이 값을 사용해야 하는게 아니라면 CAS 알고리즘을 사용하는 Atomic 객체를 사용하는게 좋은 것 같다. 성능이 좋기 때문이다.
    
      하지만 업데이트한 후 이 값 가지고 어떠한 작업을 해야한다면, 그 사이에 다른 쓰레드가 끼어들 여지가 있기 때문에 lock을 잡아야할 것 같다.
    
### Double-checked-locking이란?
    
      락을 얻을지 말지에 대한 힌트를 통해서 락을 얻는 횟수를 줄여 성능 향상을 꾀하는 디자인 패턴이다.
    
      예를 들어 싱글톤 객체를 생성하는 과정은 멀티 쓰레드 상황에서 문제가 생길 수 있다.
    
      null체크를 하고 null이면 새로운 인스턴스를 아니면 기존 인스턴스를 반환하도록 구현했을 때, 두 쓰레드가 동시에 들어온다면 새로운 객체가 2개가 생길 수 있기 때문이다.
    
      이런 상황에서는 lock이 필요한데 사실 싱글톤 객체는 초기에만 이런 문제가 있고 그 후에 객체가 생성된 후에는 이런 문제가 없다.
    
      그래서 매번 getInstance를 할 때 마다 lock을 계속 유지하는 것은 불필요한 오버헤드다.
    
      이를 막기 위해 락을 걸지 않고 null체크한 후 락을 건 후 null체크를 하는 두번의 체크를 하는데 이것을  Double-checked-locking이라고 한다.
    
      꽤 좋은 방법 같지만 일반적으로 안티 패턴으로 불린다.
        
      ---
    
      [https://en.wikipedia.org/wiki/Double-checked_locking](https://en.wikipedia.org/wiki/Double-checked_locking)
    
### 다른 영역은 공유하면서 스택은 왜 공유하지 않을까?
    
      만약 스택을 공유한다면 어떤 쓰레드가 메소드를 실행해서 스택에 프레임이 생긴 후 다른 쓰레드가 실행한 프레임이 위에 쌓일 것이다.
    
      첫 쓰레드가 작업을 마치고 프레임이 제거된 뒤에 바로 아래에 프레임에서 작업을 다시 시작할텐데 다른 쓰레드의 프레임에 가버리니 문제가 생기지 않을까?
    
    
### 쓰레드간 힙 영역을 왜 공유해야 할까? 동시성 문제 때문에 프로그래밍하기도 힘든데
    
      쓰레드가 프로세스의 현재까지 진행된 상태와 상관없이 새로운 어떤 일을 한다면 굳이 공유하지 않아도 될 것 같다.
    
      하지만 프로세스의 현재까지 진행된 상태 바탕 위에서 뭔가 새로운 일을 한다면 힙 영역을 공유해야 가능할 것이다.
    
      또한 힙 영역을 나눠써야 할텐데 그럼 공간이 부족하지 않을까?
    
      동일하게 쓰는 객체를 쓰레드마다 여러개 생성해야되니..
    
      멀티 프로세스의 경우는 어차피 각각 힙을 갖기 때문에 공간이 충분하지만..
    
### 쓰레드는 한 번 실행히 종료되면 다시 실행할 수 없는데 왜 그럴까?
    
      쓰레드 객체는 종료된 후에도 종료되었는지에 대한 쓰레드의 상태를 얻을 수 있다.
    
      근데 다시 재사용된다면 이전 쓰레드에 대한 상태나 기록이 사라져 버리기 때문이 아닐까?
### 하드웨어 쓰레드와 소프트웨어 쓰레드의 차이는? ★
    
    하드웨어 쓰레드는 가상의 코어라고 할 수 있다.
    
    소프트웨어 쓰레드는 이 가상의 코어 위에서 동작하는 프로세스의 흐름이다.
    
    기본적으로 코어 1개는 1개의 하드웨어 쓰레드를 갖고 있다고 할 수 있으며 하이퍼쓰레딩 방식을 이용해 하드웨어 쓰레드를 여러개로 늘릴 수 있다.
    
    ---
    
    [https://www.hp.com/us-en/shop/tech-takes/what-is-hyperthreading#:~:text=Hyper-threading is a process,threads or 4 virtual cores](https://www.hp.com/us-en/shop/tech-takes/what-is-hyperthreading#:~:text=Hyper-threading%20is%20a%20process,threads%20or%204%20virtual%20cores).
    
    [https://juneyr.dev/thread](https://juneyr.dev/thread)

### 스레드는 CPU코어와 관련있는데, 이러한 코어의 개수에 비해 자바 등 프로그램에서 더 많은 스레드를 할당하여 사용하는 이유가 무엇일까요? ★
    
    보통 하나의 쓰레드는 일정 시간동안 CPU를 100% 사용하지 않는다.
    
    70%를 CPU에 사용한다면 30%는 I/O와 같은 CPU가 필요없는 작업을 한다.
    
    이 시간동안 CPU를 놀게하는 것보다 다른 쓰레드에 CPU를 할당해주는 것이 효율적이다. 
    
    또한 10개의 작업이 동시에 처리해야하는 상황이 있다고 가정하자.
    
    4코어일 때 4쓰레드만 사용한다면 나머지 6개의 작업은 앞 작업이 끝날 때까지 기다려야 할 것이다.
    
    따라서 코어의 갯수에 맞춰서 쓰레드를 생성하는 것보다는 더 많은 쓰레드를 생성하는 것이다.