   ### 쓰레드는 어떠한 배경에서 등장했을까?

     과거에는 두 가지 이상의 일을 동시에 처리하기 위해서, 혹은 둘 이상의 실행 흐름을 처리하기 위해서 하나의 프로그램에서 둘 이상의 프로세스(프로세스 링크)를 생성하는 일이 많았다고 한다.

     예를 들면 여러 서버 프로세스를 만들어 클라이언트로부터의 요청을 동시에 처리하곤 했다.

     서로 별개의 프로그램을 위해서는 어쩔 수 없는 일이지만 하나의 프로그램이 둘 이상의 프로세스 생성을 요구하는 것은 부담스러운 일이다.

     왜냐하면 프로세스가 많아질수록 컨텍스트 스위칭이 많아지고 프로세스의 생성 또한 오랜 시간이 걸리기 때문이다.

     위와 같은 문제를 해결하기 위해 쓰레드가 등장하였다.

     // 뇌를 자극하는 윈도우즈 시스템 프로그래밍 352p

     // 공룡책 177p

   ### 쓰레드란 무엇일까?

     쓰레드란 프로세스 내에서 실행되는 흐름 중 하나를 말한다.

     메모리 구조 관점에서 볼 때 프로세스는 서로 완전히 다르다.
     따라서 컨텍스트 스위칭시 많은 컨텍스트 정보를 저장하고 복원해야 한다.

     반면에 쓰레드는 code 영역 data 영역 heap 영역을 공유한다.
     (JVM 관점에서 보면 method area, heap 영역 등을 공유한다고 할 수 있다.)

     따라서 쓰레드간 컨텍스트 스위칭 시 보다 적은 정보(메모리 관련 정보를 저장할 필요 없음)를 저장하고 복원하기 때문에 프로세스 간 컨텍스트 스위칭보다 적은 시간이 소요된다.

     일반적으로 프로그램은 하나의 스레드를 갖고 있고, 둘 이상의 스레드를 가진 프로세스를 멀티쓰레드 프로세스라고 한다.

     ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2f22cb7-8660-4470-92ef-dea1e83e0a05/Untitled.png)

     출처 : [https://ko.wikipedia.org/wiki/스레드_(컴퓨팅)](https://ko.wikipedia.org/wiki/%EC%8A%A4%EB%A0%88%EB%93%9C_(%EC%BB%B4%ED%93%A8%ED%8C%85))

   ### 프로세스와 쓰레드의 차이는?

     프로세스는 서로 독립적이고 하나의 프로그램 안에 있는 쓰레드들 사이에는 서로 공유하는 요소들이 있다. 따라서 컨텍스트 스위칭에 걸리는 시간이 짧다.

     프로세스가 데이터를 공유하려면 IPC기법을 사용해야하는 반면에 쓰레드는 heap 영역이나 data 영역을 통해서 좀 더 쉽게 데이터를 공유할 수 있다.

     프로세스는 생성과 종료에 시간이 많이 드는 반면 쓰레드는 생성과 종료에 비교적 시간이 덜 든다.

   ### 컨텍스트 스위칭이란?

     컨텍스트 스위칭이란 프로세스 혹은 쓰레드가 다른 프로세스 혹은 다른 쓰레드로 스케쥴링 될 때
     현재까지의 상태(혹은 문맥)를 저장하고 다시 돌아왔을 때 이 상태를 복원하는 작업이다.

     이 상태는 PCB라는 자료구조에 저장된다.

     쓰레드는 메모리 영역을 공유하기 때문에 메모리 영역과 관련된 페이지 테이블 레지스터, MMU에 존재하는 기준 레지스터 값과 한계 레지스터 값 등을 저장하고 복원할 필요가 없다.

     이러한 이유로 프로세스 컨텍스트 스위칭보다 컨텍스트 스위칭에 걸리는 시간이 짧다.

     프로세스는 컨텍스트 스위칭 시 TLB와 cache에 저장된 요소가 flush 되기 때문에 스위칭 후 얼마간 프로세스에 성능 저하가 발생할 수 있다.

     그러나 위와 같은 문제는 프로세스 식별자를 비롯한 다양한 해결책이 사용되기 때문에 스레드 컨텍스트 스위칭보다 크게 불리한 점이라고 생각되지는 않는다.

   ### 멀티 쓰레드 방식은 언제 사용할까?
      1. 어떤 일이 동시에 처리되야 할 경우

         예를 들어 싱글 쓰레드 방식의 서버 프로그램이 있다고 하자.

         사용자가 요청을 한 경우 하나의 쓰레드가 맡아서 요청을 처리해야 한다.

         요청을 처리하는 중에 다른 사용자가 또 요청을 하는 경우 이 요청이 완료되기까지 기다려야 할 것이다.

         멀티쓰레드라면 각 요청을 각 쓰레드가 하나씩 맡아서 동시에 요청을 처리할 수 있다.

      2. 어떤 일을 빠르게 처리하고 싶은 경우

         예를 들어 1부터 100까지 더해야하고 한번에 더하기 연산을 하는데 1초가 걸린다고 가정해보자.

         싱글 쓰레드의 경우 1부터 100까지 더하는데 100초가 걸린다.

         쓰레드가 4개이고 각각 1/4씩 나누어서 처리한 후 모두 더해주면 약 25초가 걸린다.

         하지만 모든 상황에서 멀티쓰레드로 작업을 처리하는게 싱글쓰레드보다 빠르지 않으므로 상황을 잘 판단해서 사용해야 한다.

   ### 쓰레드가 많으면 무조건 작업을 빨리 처리할까?

     아니다.

     쓰레드가 많아도 코어가 쓰레드의 갯수보다 적다면 컨텍스트 스위칭을 하며 작업을 처리해야 하고 컨텍스트 스위칭에는 시간이 소요 되기 때문에 오히려 느릴 수도 있다.

     //자바의 정석 723p

   ### 멀티쓰레드 프로세스에서 하나의 쓰레드에 예외나 에러가 발생하면 어떻게 될까?

     예외나 에러가 발생한 쓰레드만 종료되며 나머지 쓰레드는 정상 실행된다.

     heap은 공유하는데 왜 oome가 떠도 정상실행되지?

     //자바의 정석 730p, 직접 실험

   ### OS의 스케쥴링과 쓰레드의 관계는 어떻게 될까?

     대부분 최신 운영체제에서 스케줄 되는 대상은 프로세스가 아니라 커널 수준 쓰레드이다.

     프로세스 간 컨텍스트 스위칭은 어떤 프로세스에 있는 쓰레드에서 다른 프로세스에 있는 쓰레드로 스케쥴링 될 때를 의미한다.

     자바의 쓰레드 또한 OS에 의해 관리되고 스케쥴링된다.

     뇌자극 // 360p

     공룡책 239p

   ### CPU 코어 개수와 스레드 개수의 상관 관계는 어떻게 될까?

     CPU 코어의 개수에 따라서 병렬적으로 실행할 수 있는 쓰레드의 개수가 정해진다.

     예를들어 CPU 코어가 4개이고 스레드 또한 4개라면 이 쓰레드들은 모두 병렬적으로 실행이 가능하다.

     그러나 CPU 코어가 1개이고 스레드가 4개라면 이 스레드들은 CPU 코어 하나가 빠르게 왔다갔다 하면서 처리하기 때문에 병렬적으로 실행되는 것처럼 보여도 실은 병렬적이지 않다.

     한 편 하이퍼스레드라는 기술은 운영체제에게 코어 하나가 여러개로 인식되게끔 할 수 있다.

     이 기술은 코어 하나가 어떤 쓰레드에 대한 작업 중 메모리 스톨 때문에 비어버린 시간을 다른 쓰레드에 할당하는 기술이다.

     따라서 8코어 CPU가 하이퍼 쓰레드 기술에 의해 16코어처럼 운영체제에 인식되더라도 병렬적으로 실행할 수 있는 쓰레드는 역시 8개라고 할 수 있다.
       
     ---

     공룡책 244p

   ### 쓰레드는 자바에서 어떻게 사용할까?
      1. Thread 클래스를 상속, Runnable 인터페이스를 구현

          class MyThread extends Thread{
              public void run() { /* 작업내용 */} //Thrad클래스의 run()을 오버라이딩
          }
          
          class MyRunnable implements Runnable{
              public void run(){/*작업내용*/} //Runnable 인터페이스의 추상메서드 run()을 구현
          }
          
          class Th1{
              public void main(String args[]){
                  MyThread t1 = new MyThread();
                  MyRunnable r = new MyRunnable();
                  Thread t2 = new Thread(r); // 생성자로 Runnable을 전달하면 start()시 run()메소드를 호출해줌
              
                  // 2가지 방법 다 Thread 클래스의 start()메소드를 사용해야 쓰레드가 시작이 된다.
                  t1.start();
                  t2.start();
              }
          }

      2. Callable 인터페이스를 구현

          class MyRunnable implements Callable<Integer>{
              public void call(){/*작업내용*/} //Runnable 인터페이스의 추상메서드 run()을 구현
          }


   ## Advanced

   ### JVM의 쓰레드 스케쥴링 방식과 OS의 스케쥴링 방식은 어떻게 상호작용할까?

     JVM은 쓰레드 스케쥴링을 OS에 맡기는 듯하다.

     [https://stackoverflow.com/questions/2816011/what-is-the-jvm-thread-scheduling-algorithm](https://stackoverflow.com/questions/2816011/what-is-the-jvm-thread-scheduling-algorithm)

     [https://stackoverflow.com/questions/41759261/how-jvm-thread-scheduler-control-threads-for-multiprocessors](https://stackoverflow.com/questions/41759261/how-jvm-thread-scheduler-control-threads-for-multiprocessors)

   ### 각 OS는 어떤 스케쥴링 방식을 사용할까?

     리눅스는 Completely Fair Scheduling(CFS)라는 알고리즘을 사용하는 듯하다.

     [https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/#:~:text=Linux uses a Completely Fair,the CPU among running threads](https://blog.acolyer.org/2016/04/26/the-linux-scheduler-a-decade-of-wasted-cores/#:~:text=Linux%20uses%20a%20Completely%20Fair,the%20CPU%20among%20running%20threads).

   ### 멀티 코어에서는 어떻게 스케쥴링이 될까?

     보통 2가지 방식이 있다.

     모든 스레드가 공통 준비 큐에 존재해서 각 코어가 하나씩 스레드를 가져가면서 처리하는 모델이다.

     두 개의 다른 프로세서가 동일한 스레드를 스케줄 하지 않도록 관리가 필요하다.

     다른 하나는 각 코어가 자신만의 준비 큐를 갖고 있는 모델이다.

     첫번째 모델과 같은 문제가 없고 캐시 메모리를 효율적으로 사용할 수 있는 반면 각각의 큐마다 부하의 양이 다를 수 있다. (한 쓰레드가 다른 프로세서로 넘어가기 쉬운 첫번째 방법은 캐쉬 메모리를 매번 리셋해야 할 확률이 크다.)

     한 편 부하의 문제도  균형 알고리즘을 사용하여 모든 프로세서 간에 부하를 균등하게 만들 수 있기 때문에 대부분의 최신 운영체제에서는 일반적으로 두번째 방법을 택한다.

     243p

   ### 사용자 수준 쓰레드와 커널 수준 쓰레드의 차이는?

     사용자 수준 쓰레드는 커널 쓰레드 위에서 동작한다.

     사용자 수준 쓰레드는 스레드 라이브러리에 의해서 스레드 관련 정보가 관리되고 스케쥴링 된다.

     커널 쓰레드는 OS에 의해서 관련 정보가 관리되고 스케쥴링 된다.

     사용자 수준 쓰레드와 커널 수준 쓰레드간에는 다대일, 일대일, 다대다 등의 관계가 있다.

     다대일 관계에서는 여러 사용자 수준 쓰레드가 하나의 커널 수준 쓰레드에 대응된다.

     따라서 어떤 사용자 수준 쓰레드가 스케쥴링 되었다고 해서 실제로 실행된다고 할 수는 없다.

     대응되는 커널 수준 쓰레드가 OS에 의해서 실제로 스케쥴링이 되어야 하기 때문이다.

     일대일 관계에서 사용자 수준 쓰레드는 커널 수준 쓰레드와 일대일로 대응된다.
     이 때 사용자 수준 쓰레드를 한 개 만들면 이와 대응되는 커널 수준 쓰레드가 만들어지며,
     사용자 수준 쓰레드가 작업을 마치고 종료되면, 커널 수준 쓰레도도 같이 종료된다.

     일대일 관계에서 사용자 수준 쓰레드의 스케쥴링은 커널 수준 쓰레드의 스케쥴링에 의존된다.

     다대다 관계는 일대일 관계를 사용했을 때 발생하는 커널 쓰레드가 너무 많아지는 문제를 해결한다.

     그러나 요즈음 대부분의 운영체제는 일대일 관계 모델을 사용한다.

     왜냐하면 다대일 관계는 다중 코어를 제대로 활용할 수 없고 다대다 관계는 구현하기가 어렵고 대부분의 시스템에서 처리 코어 수가 증가함에 따라 커널 스레드 수를 제한하는 것의 중요성이 줄어들었기 때문이다.
       
     ---

     공룡책 239, 184

   ### 쓰레드의 우선순위는 믿을만한가?

     JVM마다 쓰레드의 우선순위와 관련된 구현이 다르고, OS마다 다른 방식으로 스케쥴링하기 때문에 어떤 OS에서 실행하느냐에 따라서도 다른 결과를 얻을 수 있다.

     따라서 어떤 스레드의 높은 우선순위를 준다고 해서 더 많은 실행시간과 실행기회를 갖게 될 것이라고 확신해서는 안된다

     //자정 740p

   ### 그럼 쓰레드 우선순위는 언제 쓰면 좋을까?
   ### 쓰레드 그룹이란?

     쓰레드 그룹이란 서로 관련된 쓰레드의 그룹이다.

     마치 폴더를 생성해서 관련 있는 파일을 관리하는 것처럼 쓰레드를 그룹으로 묶어서 관리할 수 있다.

     주로 쓰레드그룹의 모든 쓰레드를 한번에 interrupt() 하는 용도로 사용한다.

     모든 쓰레드는 반드시  쓰레드 그룹에 포함되야 하며 쓰레드 그룹은 다른 쓰레드 그룹을 포함할 수 있다.

     쓰레드 그룹을 지정하지 않고 생성된 쓰레드는 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속하게 된다.

     //자바 742

   ### 데몬 쓰레드란?

     다른 일반 쓰레드의 작업을 돕는 보조적인 역할을 하는 쓰레드

     다른 쓰레드가 없다면 존재 이유가 없기 때문에 일반 쓰레드가 모두 종료되면 데몬 쓰레드는 강제적으로 자동 종료된다.

     예를 들어 가비지 컬렉터, 워드프로세서의 자동저장, 화면자동갱신 등이 있다.

   ### Thread의 메소드 start()와 Runnable의 메소드 run()의 차이는?

     Thread 메소드의 start()는 내부에서 native 메소드를 실행시킨다.

     그리고 이 native 메소드는 쓰레드를 생성하고 새로운 쓰레드에 필요한 호출스택을 생성한다.

     run()은 일반적인 메소드로 위에 생성된 호출스택에 첫 번째로 올라간다.

     쓰레드가 종료되면 이렇게 만들어진 호출스택도 소멸된다.

     // 자바의 정석 729

   ### 메인 쓰레드가 종료되면 프로그램이 종료될까?

     아니다. 데몬 쓰레드를 제외한 모든 쓰레드가 작업을 마칠 때까지 프로그램은 종료되지 않는다.

     //자바의 정석 729p

