### BASIC

### 공부해야 하는 이유는?
    
    스프링의 핵심 개념이다.
    
    스프링을 이해하는데 도움을 준다.
    
### 정의는?
    
    스프링 빈이란 스프링 IOC 컨테이너에 의해 관리되는 객체를 의미한다.
    
    ---
    
    [https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction)
    
### 왜 나왔을까?
### 어떤 방식으로 동작할까?
    
    프로그램이 실행되면 스프링 컨테이너(Application Context)가 생성되고 내부에 빈 저장소라고하는 것을 갖고 있다.
    
    빈들은 각각 빈의 이름을 key 참조 객체를 value로 이 빈 저장소에 저장된다.
    

### ADVANCED

### 스프링 컨테이너는 어떻게 빈을 싱글톤으로 관리할까?
    
    바이트코드 조작 라이브러리인 CGLIB을 통해서 Configuration을 담당하는 클래스에 빈 생성 메소드를 조작한 프록시 객체를 만든다.
    
    그리고 이 객체는 만약에 빈이 이미 생성되어 있으면 빈 저장소에 등록되어 있는 빈을 반환하고
    생성되어 있지 않다면 실제 Configuration 객체의 메소드를 실행해서 나온 객체를 반환하라. 와 같은 로직을 갖고 있을 것이다. 
    
    ---
    
    김영한, 스프링 핵심 원리 - 기본편, 인프런, @Configuration과 바이트코드 조작의 마법 파트


## 빈 스코프
### 빈스코프란?
    
    스프링 컨테이너가 빈을 관리하는 범위
    
### 빈스코프가 존재하는 이유는?
    
    스프링 컨테이너는 기본적으로 빈을 싱글톤으로 관리하며 스프링 컨테이너의 생성부터 소멸까지 함께한다. 이런 식으로 작동되질 않는 빈들도 있을 것이다.
    
    그런 빈들을 위해 사용해야 한다.
    
### 싱글톤 빈이란?
    
    스프링 컨테이너의 생성부터 소멸까지 함께하며 싱글톤으로 존재하는 빈.
    
### 프로토타입 빈이란?
    
    스프링 컨테이너에 요청할 때 생성되어서 의존관계 주입이 이루어지고 초기화까지 진행되고 그 후에는 스프링 컨테이너가 관리하지 않는 빈. 따라서 @preDestroy로 지정된 메소드를 스프링컨테이너가 호출해주지 않는다. 
    
    요청할 때마다 새로운 빈이 생성되어서 반환된다. 즉 싱글톤이 아니다.
    
### request 스코프를 가진 빈은 언제 사용할까?
    
    일반적인 싱글톤 빈을 사용하면 모든 웹 요청에 동일한 빈이 사용된다. 이 때 각 요청마다 다른 빈을 사용하고 싶고 한 요청안에서는 동일한 빈을 사용하고 싶을 때가 있다. 예를 들어 한 유저가 요청을 시작해서 응답이 완료되기까지 이 유저를 구분해서 로그를 남기고 싶을 때가 있을 수 있다. 이럴 때는 각 요청마다 다른 Logger 인스턴스가 필요하고 같은 요청 안에서는 같은 Logger를 사용하고 싶을 것이다.
    
### request 스코프를 가진 빈을 사용할 때 문제점은 무엇이 있고 어떻게 해결할까?
    
    싱글톤 빈이 ‘의존관계 주입’을 받아서 사용할 때 문제가 있다.
    
    스프링 컨테이너는 생성되고 싱글톤 빈을 생성하면서 의존관계를 모두 해결해줘야 한다. request scope 빈은 고객의 요청이 들어올 때 생성되기 때문에 이 때는 아직 생성이 안된 상태다. 이 때 어떤 싱글톤 빈이 request 스코프 빈을 의존하고 있다면 request 빈이 아직 생성이 안되었기 때문에 주입을 해줄 수가 없다.
    
    **해결책** 
    
    1. 프로토타입 빈과 마찬가지로 ObejectProvier나 Provider를 이용해서 사용하는 시점(웹 요청이 들어온 시점)에 꺼내서 쓰면 된다. ObjectProvider나 Provider는 싱글톤 빈으로 스프링 컨테이너의 생성 때부터 존재하기 때문에 문제없이 의존관계 주입이 완료된다.
    2. 싱글톤 빈인 프록시 객체를 사용하여 의존관계를 문제없이 주입받고, 실제로 사용할 때도 프록시 객체를 이용하여 사용한다. 프록시 객체는 웹 요청 이후 실제 객체를 내부에 갖게 되고 기능을 위임한다.
        
        개발자는 단순히 
        @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)로
        애노테이션만 변경해주면 된다.
        
    
    **결론**
    
    프록시를 이용한 방식이 코드를 조금 더 줄여주기 때문에 프록시 방식을 사용하자.
    
### 싱글톤 빈과 프로토타입 빈을 같이 사용할 때 어떤 문제가 있고 어떻게 해결할까?
    
    싱글톤 빈 입장에서 프로토타입 빈을 의존관계 주입 방식으로 받을 때 문제가 생긴다.
    
    보통 프로토타입 빈을 사용하는 이유는 사용할 때마다 새로 생성해서 사용하기 위함이다. 그런데 싱글톤 빈 입장에서 초기에 프로토타입 빈을 주입 받아버리면 그 주입받은 빈을 계속 사용하기 때문에 의도한대로 동작하지 않는다. 
    
    따라서 이 때는 의존관계 주입 방법(DI)을 사용하면 안되면 안되고 의존관계 찾기(Dependency Lookup)방식을 사용해야 한다. 그냥 빈 사용을 원할 때마다 빈을 그 때 그 때 찾아서 사용하는 방식이다.
    
    ObjectProvider, Provider를 이용하는 방법이 있고 정확한 사용법은 직접 이 키워드로 찾아보자. 혹은 김영한님 강의파일을 보자.