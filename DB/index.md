### Index란? ★
    
    인덱스란 어떠한 테이블에 있는 데이터의 검색, 정렬, 그루핑과 같은 작업을 빠르게 하기 위해서 만드는 자료다.
    
    인덱스의 노드는 보통 테이블에 칼럼과 같은 값을 갖는 키와 데이터의 주소 형태로 구성되며 빠른 검색을 위해 키를 기준으로 정렬된다.
    
    인덱스를 구성하는 노드는 하나에서부터 여러개가 될 수 있다.
    
    인덱스를 구성하는 단계에 따라 단일 단계 인덱스, 다단계 인덱스로 나뉜다.
    
        
    
### 왜 검색이 삽입, 삭제, 수정보다 중요할까?
    
    일반적인 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)에서는 쓰기와 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기(INSERT, UPDATE, DELETE)를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요하다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 275p, 2022
    
### sparse index dense index란?
    
    희소 인덱스는 각 데이터 블록 당 1개의 인덱스를 갖는 방식이고,
    밀집 인덱스는 모든 데이터 레코드 당 1개의 인덱스를 갖는 방식이다.
    
    희소 인덱스는 데이터가 그 인덱스에 대해 클러스터링 된 상태에서만 가능하다. 
    클러스터링 되었다는 것은 정렬되어 있다는 것이다.
    그래야 블록을 찾고 그 블록만을 탐색하면 되기 때문이다.
    
    여기서 블록은 한번에 데이터를 읽어오고 쓰는 단위이다.
    
    블록의 크기가 4kb라고 하고 레코드 하나의 크기가 100byte라 한다면 약 40개 정도의 레코드를 블록 하나에 저장할 수 있는 것이다. 
    
    ---
    
    [http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)
    
    [https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)
    
### primary index secondary index란?
    
    기본 인덱스는 탐색 키가 데이터 테이블의 기본 키인 경우를 기본 인덱스라 한다.
    
    그외 인덱스를 보조 인덱스라 한다.
    
    ---
    
    [http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)
    
    [https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)
    
### clustering index란? ★
    
    프라이머리 키에 따라 테이블 자체가 정렬이 될 때 테이블 자체가 인덱스가 된다.
    
    이 인덱스를 클러스터링 인덱스 또는 클러스터링 테이블이라고 부른다.
    
    이 테이블은 리프 노드가 주소 값이 적힌 노드가 아니라 실제 데이터를 포함하고 있는 노드라는 점을 빼면 다른 인덱스와 같이 B-Tree 자료구조를 갖는다.
    
    클러스터링 테이블은 그자체가 하나의 거대한 인덱스 구조라고 보면 된다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 270p, 2022
    
### clustering index의 장점과 단점은?
    - 장점
        - 검색할 때 처리 성능이 매우 빠르다.
            - 일반 검색 - 보통 빠름
                
                왜냐하면 리프 노드에 바로 데이터가 존재하기 때문에 클러스터링 테이블과 동일한 깊이의 인덱스를 가진 논 클러스터링 테이블에 비해 디스크 접근 횟수가 1 작다.
                
            - 범위 검색 - 매우 빠름
                
                정렬되어있지 않은 다른 논 클러스터링 테이블이 블록 20개에 접근해서 1~20사이에 범위 검색을 진행한다고 하자.
                
                클러스터링 인덱스의 경우 데이터 자체가 정렬되어 저장되기 때문에
                어떤 범위에 있는 데이터들이 이미 한 블록에 모여있다.
                
                따라서 1~20 사이에 데이터들이 한 블록에 있다면, 단 한번에 블록 접근으로 검색이 완료된다.
                
            - 순차 검색 - 매우 빠름
                
                왜냐하면 이미 메모리로 한 번 가져온 블록에 다음 데이터가 있기 때문에(정렬되어 있으므로) 디스크에 접근할 필요가 없다.
                
    - 단점
        - 클러스터링 인덱스를 가지지 않은 테이블보다 세컨더리 인덱스 검색에서 속도가 느리다.
            
            클러스터링 인덱스를 가진 테이블은 세컨더리 인덱스 구성시 리프 노드에 실제 주소가 아닌 프라이머리 키 값을 가지게 된다. 
            
            왜냐하면 프라이머리 키를 갖고 다시 클러스터링 테이블에 트리를 따라 내려가면서 리프 노드에 도착해야 하기 때문이다.
            
            이렇게 트리 탐색이 2번에 걸쳐 진행되기 때문에 클러스터링 인덱스를 가지지 않은 테이블보다 세컨더리 인덱스 검색에서 속도가 느리다.
            
        - 쓰기(INSERT, UPDATE, DELETE)가 느리다.
            
            왜냐하면 데이터 추가 수정(프라이머리 키 수정) 삭제를 할 때마다 세컨더리 인덱스와 클러스터링 테이블에 대해서 B-Tree 자료 구조를 유지하기 위한 작업이 필요하기 때문이다.
            
        - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 275p, 2022
    
### Index는 어떤 자료구조로 되어있는가? 장점과 단점은 무엇인가? ★
    - B-tree
        
        인덱스 노드 자체는 이진 트리로 구성되어 있으며 인덱스의 노드들은 B-tree로 구성된다.
        
        B는 Balanced의 약자로 즉 균형잡힌 트리를 의미한다.
        
        이진 트리와는 다르게 한 노드가 여러노드를 자식으로 둘 수 있으며 모든 루트 노드부터
        모든 리프까지의 높이가 모두 같다.
        
        리프 노드들은 서로 링크되어 있어서 하나의 리프 노드에서 다음 리프 노드로 접근할 수 있다.
        
    - 장점
        - 검색 성능이 뛰어나다.
    - 단점
        - 인덱스의 자료구조를 유지해야 하기 때문에 삽입, 삭제, 수정시 성능이 떨어진다.
        - 100% 일치하거나 값의 앞부분만 일치하는 경우에만 사용할 수 있다.
            
            왜냐하면 앞부분만 사용해도 인덱스의 정렬된 구조를 이용할 수 있는데 뒷부분은 그게 안되기 때문이다.
            
        - 함수나 연산을 수행한 결과를 사용할 수는 없다.
        - 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 사용할 수 없다.
        
        ---
        
        백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 8장, 2022
        
        - 인덱스의 자료구조로 B-tree가 많이 쓰이는 이유는 무엇일까?
            - vs 해시 테이블
                
                해시 테이블은 특정 하나의 데이터를 찾는데는 빠르지만 범위 검색에는 유용하지 않기 때문에 해시 테이블은 사용하지 않는다.
                
                (사실 해시 테이블 같은 경우 정확히 어떻게 해시 테이블로 인덱스를 구현할 수 있는지 감이 잡히지 않는다.)
                
            - vs Red Black Tree
                
                Red Black Tree 같은 경우는 노드에 데이터를 하나 밖에 저장할 수 없다.
                
                즉 인덱스로 구성될 모든 엔트리에 대해서 각각 대응되는 노드를 가질 수 밖에 없고,
                b-tree에 비해 트리의 높이가 훨씬 길어진다.
                
                성능에서 가장 중요한 것은 디스크 접근 횟수를 줄이는 것이다.
                
                노드를 한번씩 탐색한다는 것은 디스크에 한 번씩 접근한다는 의미다.
                
                따라서 높이가 낮은 b-tree가 성능상 훨씬 유리하다.
                
                b-tree도 결국 노드를 찾은 후에 노드 안에서 데이터를 또 탐색해야 하지만,
                이 작업은 디스크를 읽는 것보다는 훨씬 빠르다.
                
            
            ---
            
            [https://helloinyong.tistory.com/296](https://helloinyong.tistory.com/296)
            
### 왜 인덱스로  Cardinality가 높은 칼럼을 사용하는게 좋을까?
    
    인덱스는 Cardinality가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빨리 처리된다.
    
    예를 들어 다음과 같은 상황이 있다고 하자.
    
    테이블 이름 : tb ,레코드 건수 1만건 , country 칼럼으로 인덱스 있음
    
    케이스 A : country 칼럼의 유니크한 값의 개수 10개
    
    케이스 B : country 칼럼의 유니크한 값의 개수 1000개
    
    SELECT *
    FROM tb
    WHERE country='KOREA' AND city='SEOUL';
    
    케이스 A의 경우 먼저 country 인덱스로 한 번 필터링 거친 후에 남는 데이터는 1000개가 있을 것이다. 
    
    이 1000개의 데이터가 모두 다른 블록에 저장되어 있다면 최악의 경우 1000번 데이터 블록에 접근해서 city값이 ‘SEOUL’과 같은지 확인한 후 데이터를 가져올 것이다.
    
    케이스 B의 경우 단 10번만 접근하면 된다. 
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 228p, 2022
    
### 복합키 인덱스는 어떻게 저장될까?
    
    복합키를 이루는 칼럼들이 하나도 합쳐진다.
    
    그리고 합쳐진 칼럼에 대하여 b-tree가 구성된다.
    
    ---
    
    [https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/](https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/)
    
### 나이, 성별, 주민번호를 사용하여 복합 인덱스를 만들 때 고려해야할 점은 무엇일까? ★
    
    주민번호는 유니크하기 때문에 굳이 같이 복합 인덱스를 만들 필요가 없다고 생각한다.

    어차피 WHERE절에 주민번호만 있으면 모두 걸러지기 때문이다.
    
    - 과연 그럴까?
        
        예를 들어 쿼리가 다음과 같다고 해보자.
        
        SELECT * 주민번호, 나이, 성별 WHERE 나이 >= 21 AND 성별='남자'
        
        주민번호가 복합 인덱스로 지정되어 있지 않다면 WHERE문을 만족하는 엔트리마다 데이터 테이블에 모두 접근해서 주민번호값을 읽어야 한다.
        
        주민번호가 복합 인덱스로 지정된 경우에는 리프노드에 이미 주민번호가 같이 저장되어 있기 때문에 인덱스만으로 쿼리를 처리할 수 있어 훨씬 빠를 수 있다.
        
    
    따라서 나이, 성별을 복합 인덱스로 만든다고 가정해보자.
    
    복합 인덱스를 만들 때는 자주 사용되는쿼리에 사용되는 조건이 동등 조건인지 범위 조건인지를 봐야 한다.
    
    이를 통해서 최대한 많은 조건이 작업 범위 결정 조건으로 사용될 수 있도록 잘 조정해야 된다.
    
    이 때 ‘작업 범위 결정 조건’이란 i/o작업의 범위를 줄여주는 조건을 말한다.
    
    예를 들어 다음과 같은 쿼리가 자주 사용된다고 해보자.
    
    SELECT * From Members Where age >= 21 AND sex='M';
    
    이 때 인덱스를 다음과 같이 구성한다고 가정해보자.
    
    case A : age, sex
    
    이 경우 나이가 21살인 레코드를 찾고 마지막 리프 노드까지 내려가면서 성별이 남자인지 모두 비교를 해야 한다.
    
    만약 21살 이상인 사람이 100명이라면 100번의 랜덤i/o 작업을 통해 비교해야 한다.
    
    이 때 age ≥ 21 는 ‘작업 범위 결정 조건’이라 하고 sex=’M’은 ‘필터링 조건’이라 한다. 
    
    case B : sex, age
    
    이 경우 성별이 남자이고 나이가 21인 리프 노드를 찾고 성별이 여자인 엔트리를 만날 때까지 아래로 스캔해주면 된다. 왜냐하면 같은 성별끼리 나이에 따라 정렬되어 있기 때문이다.
    
    만약 21살 이상인 사람이 100명이고 그 중에 성별이 남자인 사람이 50명이라면 50번의 랜덤 i/o작업을 통해 비교하면 된다.
    
    두 조건 모두 작업 범위를 줄여 주었으므로 ‘작업 범위 결정 조건’이라 할 수 있다.
    
    위 예에서도 알 수 있듯이 ‘작업 범위 결정 조건’을 많이 해당되게 할수록 쿼리의 성능이 올라간다.
    
    어떤 조건이 인덱스에 칼럼 순서와 상관없이 작업범위 결정 조건으로 사용할 수 없는 것들이 있는데 이 것은 Real MySQL 251p를 참고한다.
    
    ---
    
     백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 247-249, 2022
### 커버링 인덱스란?
    
    데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 커버링 인덱스 방식을 사용했다고 한다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 476p, 2022
    
### Where절에 연산하거나 함수를 사용한 key로는 b-tree 인덱스를 쓸 수 없다. 대안은? ★
    
    가상 칼럼 인덱스를 쓰거나 함수 인덱스(MySQL8.0부터 가능)를 사용한다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 266-267, 2022   
### Index를 만들면 DBMS가 항상 Index를 이용해서 탐색을 할까?
    
    인덱스를 만든다고 해서 DBMS가 쿼리를 처리할 때 무조건 사용하는 것은 아니다.
    
    사용할 때보다 안한게 더 빠르다고 판단되면 인덱스를 사용하지 않는다.
    
### 인덱스 하나에 칼럼을 여러개 사용하는 것(복합 인덱스)과 칼럼 당 인덱스를 만드는 것의 차이는?
    - 단일 조건에서는 싱글 인덱스는 복합키 인덱스보다 성능이 좋다.
        
        → 왜냐하면 key의 크기가 작기 때문에 노드 하나당 많은 엔트리가 들어가서 b-tree의 깊이가 낮을 수 있다.
        
    - 여러 조건에서는 복합키 인덱스가 성능이 좋다. (복합키에 사용된 칼럼이 모두 조건으로 사용되거나 검색하고자하는 열에 포함된 경우)
        
        → 왜냐하면 복합키 인덱스는 싱글 인덱스가 줄여주는 범위를 미니멈으로 갖고 더 많이 범위를 줄여서 스캔 가능하기 때문에 블록에 덜 접근한다. 물론 칼럼의 순서를 잘 구성해주어야 한다.
        

    따라서 어떤 칼럼이 자주 같이 사용되는 경우 두 칼럼을 인덱스로 함께 구성해주는 것이 좋다.
### 인덱스 선정시 고려사항은 어떻게 될까?
    
    가장 중요한 질문은 이것이다.
    
    ‘어떻게하면 가장 중요한 쿼리들에 대해 가장 최적의 실행 계획을 만들 수 있을 것인가?’
    
    위 질문을 해결하기 위해서 다음과 같은 고민을 한다.
    
    어떤 테이블에 인덱스를 생성할까?
    
    어떤 칼럼을 키로 선정할까?
    
    몇 개의 인덱스를 생성할까?
    
    인덱스를 밀집 인덱스, 희소 인덱스 중 어떤 유형으로 만들까?
    
    계속 인덱스를 추가해보고 실행 계획을 살펴보면서 끊임없이 개선해야 함.
    
### 왜 대량의 데이터에서 소수의 데이터가 아닌 대량의 데이터를 탐색할 때는 인덱스가 안 좋을까?

---

### 참고자료

[http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)

[https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)## Index는 어떤 자료구조로 되어있는가? 장점과 단점은 무엇인가? ★