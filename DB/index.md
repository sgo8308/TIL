### Index란? ★
    
    인덱스란 어떠한 테이블에 있는 데이터의 검색, 정렬, 그루핑과 같은 작업을 빠르게 하기 위해서 만드는 자료다.
    
    인덱스의 노드는 보통 테이블에 칼럼과 같은 값을 갖는 키와 데이터의 주소 형태로 구성되며 빠른 검색을 위해 키를 기준으로 정렬된다.
    
    인덱스를 구성하는 노드는 하나에서부터 여러개가 될 수 있다.
    
    인덱스를 구성하는 단계에 따라 단일 단계 인덱스, 다단계 인덱스로 나뉜다.
    
        
    
### 왜 검색이 삽입, 삭제, 수정보다 중요할까?
    
    일반적인 웹 서비스와 같은 온라인 트랜잭션 환경(OLTP, On-Line Transaction Processing)에서는 쓰기와 비율이 2:8 또는 1:9 정도이기 때문에 조금 느린 쓰기(INSERT, UPDATE, DELETE)를 감수하고 읽기를 빠르게 유지하는 것은 매우 중요하다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 275p, 2022
    
### sparse index dense index란?
    
    희소 인덱스는 각 데이터 블록 당 1개의 인덱스를 갖는 방식이고,
    밀집 인덱스는 모든 데이터 레코드 당 1개의 인덱스를 갖는 방식이다.
    
    희소 인덱스는 데이터가 그 인덱스에 대해 클러스터링 된 상태에서만 가능하다. 
    클러스터링 되었다는 것은 정렬되어 있다는 것이다.
    그래야 블록을 찾고 그 블록만을 탐색하면 되기 때문이다.
    
    여기서 블록은 한번에 데이터를 읽어오고 쓰는 단위이다.
    
    블록의 크기가 4kb라고 하고 레코드 하나의 크기가 100byte라 한다면 약 40개 정도의 레코드를 블록 하나에 저장할 수 있는 것이다. 
    
    ---
    
    [http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)
    
    [https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)
    
### primary index secondary index란?
    
    기본 인덱스는 탐색 키가 데이터 테이블의 기본 키인 경우를 기본 인덱스라 한다.
    
    그외 인덱스를 보조 인덱스라 한다.
    
    ---
    
    [http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)
    
    [https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)
    
### clustering index란? ★
    
    프라이머리 키에 따라 테이블 자체가 정렬이 될 때 테이블 자체가 인덱스가 된다.
    
    이 인덱스를 클러스터링 인덱스 또는 클러스터링 테이블이라고 부른다.
    
    이 테이블은 리프 노드가 주소 값이 적힌 노드가 아니라 실제 데이터를 포함하고 있는 노드라는 점을 빼면 다른 인덱스와 같이 B-Tree 자료구조를 갖는다.
    
    클러스터링 테이블은 그자체가 하나의 거대한 인덱스 구조라고 보면 된다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 270p, 2022
    
### clustering index의 장점과 단점은?
    - 장점
        - 검색할 때 처리 성능이 매우 빠르다.
            - 일반 검색 - 보통 빠름
                
                왜냐하면 리프 노드에 바로 데이터가 존재하기 때문에 클러스터링 테이블과 동일한 깊이의 인덱스를 가진 논 클러스터링 테이블에 비해 디스크 접근 횟수가 1 작다.
                
            - 범위 검색 - 매우 빠름
                
                정렬되어있지 않은 다른 논 클러스터링 테이블이 블록 20개에 접근해서 1~20사이에 범위 검색을 진행한다고 하자.
                
                클러스터링 인덱스의 경우 데이터 자체가 정렬되어 저장되기 때문에
                어떤 범위에 있는 데이터들이 이미 한 블록에 모여있다.
                
                따라서 1~20 사이에 데이터들이 한 블록에 있다면, 단 한번에 블록 접근으로 검색이 완료된다.
                
            - 순차 검색 - 매우 빠름
                
                왜냐하면 이미 메모리로 한 번 가져온 블록에 다음 데이터가 있기 때문에(정렬되어 있으므로) 디스크에 접근할 필요가 없다.
                
    - 단점
        - 클러스터링 인덱스를 가지지 않은 테이블보다 세컨더리 인덱스 검색에서 속도가 느리다.
            
            클러스터링 인덱스를 가진 테이블은 세컨더리 인덱스 구성시 리프 노드에 실제 주소가 아닌 프라이머리 키 값을 가지게 된다. 
            
            왜냐하면 프라이머리 키를 갖고 다시 클러스터링 테이블에 트리를 따라 내려가면서 리프 노드에 도착해야 하기 때문이다.
            
            이렇게 트리 탐색이 2번에 걸쳐 진행되기 때문에 클러스터링 인덱스를 가지지 않은 테이블보다 세컨더리 인덱스 검색에서 속도가 느리다.
            
        - 쓰기(INSERT, UPDATE, DELETE)가 느리다.
            
            왜냐하면 데이터 추가 수정(프라이머리 키 수정) 삭제를 할 때마다 세컨더리 인덱스와 클러스터링 테이블에 대해서 B-Tree 자료 구조를 유지하기 위한 작업이 필요하기 때문이다.
            
        - 테이블의 모든 세컨더리 인덱스가 클러스터링 키를 갖기 때문에 클러스터링 키 값의 크기가 클 경우 전체적으로 인덱스의 크기가 커진다.
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 275p, 2022
    
### Index는 어떤 자료구조로 되어있는가? 장점과 단점은 무엇인가? ★
    - B-tree
        
        인덱스 노드 자체는 이진 트리로 구성되어 있으며 인덱스의 노드들은 B-tree로 구성된다.
        
        B는 Balanced의 약자로 즉 균형잡힌 트리를 의미한다.
        
        이진 트리와는 다르게 한 노드가 여러노드를 자식으로 둘 수 있으며 모든 루트 노드부터
        모든 리프까지의 높이가 모두 같다.
        
        리프 노드들은 서로 링크되어 있어서 하나의 리프 노드에서 다음 리프 노드로 접근할 수 있다.
        
    - 장점
        - 검색 성능이 뛰어나다.
    - 단점
        - 인덱스의 자료구조를 유지해야 하기 때문에 삽입, 삭제, 수정시 성능이 떨어진다.
        - 100% 일치하거나 값의 앞부분만 일치하는 경우에만 사용할 수 있다.
            
            왜냐하면 앞부분만 사용해도 인덱스의 정렬된 구조를 이용할 수 있는데 뒷부분은 그게 안되기 때문이다.
            
        - 함수나 연산을 수행한 결과를 사용할 수는 없다.
        - 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 사용할 수 없다.
        
        ---
        
        백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 8장, 2022
        
        - 인덱스의 자료구조로 B-tree가 많이 쓰이는 이유는 무엇일까?
            - vs 해시 테이블
                
                해시 테이블은 특정 하나의 데이터를 찾는데는 빠르지만 범위 검색에는 유용하지 않기 때문에 해시 테이블은 사용하지 않는다.
                
                (사실 해시 테이블 같은 경우 정확히 어떻게 해시 테이블로 인덱스를 구현할 수 있는지 감이 잡히지 않는다.)
                
            - vs Red Black Tree
                
                Red Black Tree 같은 경우는 노드에 데이터를 하나 밖에 저장할 수 없다.
                
                즉 인덱스로 구성될 모든 엔트리에 대해서 각각 대응되는 노드를 가질 수 밖에 없고,
                b-tree에 비해 트리의 높이가 훨씬 길어진다.
                
                성능에서 가장 중요한 것은 디스크 접근 횟수를 줄이는 것이다.
                
                노드를 한번씩 탐색한다는 것은 디스크에 한 번씩 접근한다는 의미다.
                
                따라서 높이가 낮은 b-tree가 성능상 훨씬 유리하다.
                
                b-tree도 결국 노드를 찾은 후에 노드 안에서 데이터를 또 탐색해야 하지만,
                이 작업은 디스크를 읽는 것보다는 훨씬 빠르다.
                
            
            ---
            
            [https://helloinyong.tistory.com/296](https://helloinyong.tistory.com/296)
            
### 왜 인덱스로  Cardinality가 높은 칼럼을 사용하는게 좋을까?
    
    인덱스는 Cardinality가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빨리 처리된다.
    
    예를 들어 다음과 같은 상황이 있다고 하자.
    
    테이블 이름 : tb ,레코드 건수 1만건 , country 칼럼으로 인덱스 있음
    
    케이스 A : country 칼럼의 유니크한 값의 개수 10개
    
    케이스 B : country 칼럼의 유니크한 값의 개수 1000개
    
    SELECT *
    FROM tb
    WHERE country='KOREA' AND city='SEOUL';
    
    케이스 A의 경우 먼저 country 인덱스로 한 번 필터링 거친 후에 남는 데이터는 1000개가 있을 것이다. 
    
    이 1000개의 데이터가 모두 다른 블록에 저장되어 있다면 최악의 경우 1000번 데이터 블록에 접근해서 city값이 ‘SEOUL’과 같은지 확인한 후 데이터를 가져올 것이다.
    
    케이스 B의 경우 단 10번만 접근하면 된다. 
    
    ---
    
    백은빈, 이성욱, Real MySQL 8.0, 2쇄, 위키북스, 228p, 2022
    
### 복합키 인덱스는 어떻게 저장될까?
    
    복합키를 이루는 칼럼들이 하나도 합쳐진다.
    
    그리고 합쳐진 칼럼에 대하여 b-tree가 구성된다.
    
    ---
    
    [https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/](https://www.freecodecamp.org/news/database-indexing-at-a-glance-bb50809d48bd/)
    
### 나이, 성별, 주민번호를 사용하여 복합 인덱스를 만들 때 고려해야할 점은 무엇일까? ★
    
    만약 주민번호만으로 쿼리가 자주
    
    먼저 어떤 쿼리가 자주 사용되는지 분석을 해야 한다.
    
    만약 주민번호만을 
    
### Where절에 연산하거나 함수를 사용한 key로는 b-tree 인덱스를 쓸 수 없다. 대안은? ★
### Index를 만들면 DBMS가 항상 Index를 이용해서 탐색을 할까?
    
    인덱스를 만든다고 해서 DBMS가 쿼리를 처리할 때 무조건 사용하는 것은 아니다.
    
    사용할 때보다 안한게 더 빠르다고 판단되면 인덱스를 사용하지 않는다.
    
### 인덱스 하나에 칼럼을 여러개 사용하는 것(복합 인덱스)과 칼럼 당 인덱스를 만드는 것의 차이는?
### 인덱스 선정시 고려사항은 어떻게 될까?
    
    가장 중요한 질문은 이것이다.
    
    ‘어떻게하면 가장 중요한 쿼리들에 대해 가장 최적의 실행 계획을 만들 수 있을 것인가?’
    
    위 질문을 해결하기 위해서 다음과 같은 고민을 한다.
    
    어떤 테이블에 인덱스를 생성할까?
    
    어떤 칼럼을 키로 선정할까?
    
    몇 개의 인덱스를 생성할까?
    
    인덱스를 밀집 인덱스, 희소 인덱스 중 어떤 유형으로 만들까?
    
    계속 인덱스를 추가해보고 실행 계획을 살펴보면서 끊임없이 개선해야 함.
    
### 왜 대량의 데이터에서 소수의 데이터가 아닌 대량의 데이터를 탐색할 때는 인덱스가 안 좋을까?

---

[http://www.kocw.net/home/cview.do?cid=d549f8570583094b](http://www.kocw.net/home/cview.do?cid=d549f8570583094b)

[https://slidesplayer.org/slide/16694236/](https://slidesplayer.org/slide/16694236/)## Index는 어떤 자료구조로 되어있는가? 장점과 단점은 무엇인가? ★